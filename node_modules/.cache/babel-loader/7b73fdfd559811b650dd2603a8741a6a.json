{"ast":null,"code":"import { calcExactPositionOrRandomFromSize, clamp, getDistance, getParticleBaseVelocity, getParticleDirectionAngle, getRandom, getRangeValue, getValue, randomInRange, setRangeValue } from \"../Utils/NumberUtils\";\nimport { deepExtend, getPosition, initParticleNumericAnimationValue, isInArray, itemFromSingleOrMultiple } from \"../Utils/Utils\";\nimport { getHslFromAnimation, rangeColorToRgb } from \"../Utils/ColorUtils\";\nimport { Interactivity } from \"../Options/Classes/Interactivity/Interactivity\";\nimport { Vector } from \"./Utils/Vector\";\nimport { Vector3d } from \"./Utils/Vector3d\";\nimport { alterHsl } from \"../Utils/CanvasUtils\";\nimport { errorPrefix } from \"./Utils/Constants\";\nimport { loadParticlesOptions } from \"../Utils/OptionsUtils\";\n\nconst fixOutMode = data => {\n  if (!isInArray(data.outMode, data.checkModes)) {\n    return;\n  }\n\n  const diameter = data.radius * 2;\n\n  if (data.coord > data.maxCoord - diameter) {\n    data.setCb(-data.radius);\n  } else if (data.coord < diameter) {\n    data.setCb(data.radius);\n  }\n};\n\nexport class Particle {\n  constructor(engine, id, container, position, overrideOptions, group) {\n    var _this = this;\n\n    this.container = container;\n\n    this._calcPosition = function (container, position, zIndex) {\n      let tryCount = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\n      for (const [, plugin] of container.plugins) {\n        const pluginPos = plugin.particlePosition !== undefined ? plugin.particlePosition(position, _this) : undefined;\n\n        if (pluginPos) {\n          return Vector3d.create(pluginPos.x, pluginPos.y, zIndex);\n        }\n      }\n\n      const canvasSize = container.canvas.size,\n            exactPosition = calcExactPositionOrRandomFromSize({\n        size: canvasSize,\n        position: position\n      }),\n            pos = Vector3d.create(exactPosition.x, exactPosition.y, zIndex),\n            radius = _this.getRadius(),\n            outModes = _this.options.move.outModes,\n            fixHorizontal = outMode => {\n        fixOutMode({\n          outMode,\n          checkModes: [\"bounce\", \"bounce-horizontal\"],\n          coord: pos.x,\n          maxCoord: container.canvas.size.width,\n          setCb: value => pos.x += value,\n          radius\n        });\n      },\n            fixVertical = outMode => {\n        fixOutMode({\n          outMode,\n          checkModes: [\"bounce\", \"bounce-vertical\"],\n          coord: pos.y,\n          maxCoord: container.canvas.size.height,\n          setCb: value => pos.y += value,\n          radius\n        });\n      };\n\n      fixHorizontal(outModes.left ?? outModes.default);\n      fixHorizontal(outModes.right ?? outModes.default);\n      fixVertical(outModes.top ?? outModes.default);\n      fixVertical(outModes.bottom ?? outModes.default);\n\n      if (_this._checkOverlap(pos, tryCount)) {\n        return _this._calcPosition(container, undefined, zIndex, tryCount + 1);\n      }\n\n      return pos;\n    };\n\n    this._calculateVelocity = () => {\n      const baseVelocity = getParticleBaseVelocity(this.direction),\n            res = baseVelocity.copy(),\n            moveOptions = this.options.move;\n\n      if (moveOptions.direction === \"inside\" || moveOptions.direction === \"outside\") {\n        return res;\n      }\n\n      const rad = Math.PI / 180 * getRangeValue(moveOptions.angle.value),\n            radOffset = Math.PI / 180 * getRangeValue(moveOptions.angle.offset),\n            range = {\n        left: radOffset - rad / 2,\n        right: radOffset + rad / 2\n      };\n\n      if (!moveOptions.straight) {\n        res.angle += randomInRange(setRangeValue(range.left, range.right));\n      }\n\n      if (moveOptions.random && typeof moveOptions.speed === \"number\") {\n        res.length *= getRandom();\n      }\n\n      return res;\n    };\n\n    this._checkOverlap = function (pos) {\n      let tryCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n      const collisionsOptions = _this.options.collisions,\n            radius = _this.getRadius();\n\n      if (!collisionsOptions.enable) {\n        return false;\n      }\n\n      const overlapOptions = collisionsOptions.overlap;\n\n      if (overlapOptions.enable) {\n        return false;\n      }\n\n      const retries = overlapOptions.retries;\n\n      if (retries >= 0 && tryCount > retries) {\n        throw new Error(`${errorPrefix} particle is overlapping and can't be placed`);\n      }\n\n      return !!_this.container.particles.find(particle => getDistance(pos, particle.position) < radius + particle.getRadius());\n    };\n\n    this._getRollColor = color => {\n      if (!color || !this.roll || !this.backColor && !this.roll.alter) {\n        return color;\n      }\n\n      const backFactor = this.roll.horizontal && this.roll.vertical ? 2 : 1,\n            backSum = this.roll.horizontal ? Math.PI / 2 : 0,\n            rolled = Math.floor(((this.roll.angle ?? 0) + backSum) / (Math.PI / backFactor)) % 2;\n\n      if (!rolled) {\n        return color;\n      }\n\n      if (this.backColor) {\n        return this.backColor;\n      }\n\n      if (this.roll.alter) {\n        return alterHsl(color, this.roll.alter.type, this.roll.alter.value);\n      }\n\n      return color;\n    };\n\n    this._initPosition = position => {\n      const container = this.container,\n            zIndexValue = getRangeValue(this.options.zIndex.value);\n      this.position = this._calcPosition(container, position, clamp(zIndexValue, 0, container.zLayers));\n      this.initialPosition = this.position.copy();\n      const canvasSize = container.canvas.size;\n      this.moveCenter = { ...getPosition(this.options.move.center, canvasSize),\n        radius: this.options.move.center.radius ?? 0,\n        mode: this.options.move.center.mode ?? \"percent\"\n      };\n      this.direction = getParticleDirectionAngle(this.options.move.direction, this.position, this.moveCenter);\n\n      switch (this.options.move.direction) {\n        case \"inside\":\n          this.outType = \"inside\";\n          break;\n\n        case \"outside\":\n          this.outType = \"outside\";\n          break;\n      }\n\n      this.offset = Vector.origin;\n    };\n\n    this._loadShapeData = (shapeOptions, reduceDuplicates) => {\n      const shapeData = shapeOptions.options[this.shape];\n\n      if (!shapeData) {\n        return;\n      }\n\n      return deepExtend({\n        close: shapeOptions.close,\n        fill: shapeOptions.fill\n      }, itemFromSingleOrMultiple(shapeData, this.id, reduceDuplicates));\n    };\n\n    this._engine = engine;\n    this.init(id, position, overrideOptions, group);\n  }\n\n  destroy(override) {\n    if (this.unbreakable || this.destroyed) {\n      return;\n    }\n\n    this.destroyed = true;\n    this.bubble.inRange = false;\n    this.slow.inRange = false;\n    const container = this.container,\n          pathGenerator = this.pathGenerator;\n\n    for (const [, plugin] of container.plugins) {\n      if (plugin.particleDestroyed) {\n        plugin.particleDestroyed(this, override);\n      }\n    }\n\n    for (const updater of container.particles.updaters) {\n      if (updater.particleDestroyed) {\n        updater.particleDestroyed(this, override);\n      }\n    }\n\n    if (pathGenerator) {\n      pathGenerator.reset(this);\n    }\n  }\n\n  draw(delta) {\n    const container = this.container;\n\n    for (const [, plugin] of container.plugins) {\n      container.canvas.drawParticlePlugin(plugin, this, delta);\n    }\n\n    container.canvas.drawParticle(this, delta);\n  }\n\n  getFillColor() {\n    return this._getRollColor(this.bubble.color ?? getHslFromAnimation(this.color));\n  }\n\n  getMass() {\n    return this.getRadius() ** 2 * Math.PI / 2;\n  }\n\n  getPosition() {\n    return {\n      x: this.position.x + this.offset.x,\n      y: this.position.y + this.offset.y,\n      z: this.position.z\n    };\n  }\n\n  getRadius() {\n    return this.bubble.radius ?? this.size.value;\n  }\n\n  getStrokeColor() {\n    return this._getRollColor(this.bubble.color ?? getHslFromAnimation(this.strokeColor));\n  }\n\n  init(id, position, overrideOptions, group) {\n    const container = this.container,\n          engine = this._engine;\n    this.id = id;\n    this.group = group;\n    this.fill = true;\n    this.pathRotation = false;\n    this.close = true;\n    this.lastPathTime = 0;\n    this.destroyed = false;\n    this.unbreakable = false;\n    this.rotation = 0;\n    this.misplaced = false;\n    this.retina = {\n      maxDistance: {}\n    };\n    this.outType = \"normal\";\n    this.ignoresResizeRatio = true;\n    const pxRatio = container.retina.pixelRatio,\n          mainOptions = container.actualOptions,\n          particlesOptions = loadParticlesOptions(this._engine, container, mainOptions.particles),\n          shapeType = particlesOptions.shape.type,\n          {\n      reduceDuplicates\n    } = particlesOptions;\n    this.shape = itemFromSingleOrMultiple(shapeType, this.id, reduceDuplicates);\n    const shapeOptions = particlesOptions.shape;\n\n    if (overrideOptions && overrideOptions.shape && overrideOptions.shape.type) {\n      const overrideShapeType = overrideOptions.shape.type,\n            shape = itemFromSingleOrMultiple(overrideShapeType, this.id, reduceDuplicates);\n\n      if (shape) {\n        this.shape = shape;\n        shapeOptions.load(overrideOptions.shape);\n      }\n    }\n\n    this.shapeData = this._loadShapeData(shapeOptions, reduceDuplicates);\n    particlesOptions.load(overrideOptions);\n    const shapeData = this.shapeData;\n\n    if (shapeData) {\n      particlesOptions.load(shapeData.particles);\n    }\n\n    const interactivity = new Interactivity(engine, container);\n    interactivity.load(container.actualOptions.interactivity);\n    interactivity.load(particlesOptions.interactivity);\n    this.interactivity = interactivity;\n    this.fill = shapeData?.fill ?? particlesOptions.shape.fill;\n    this.close = shapeData?.close ?? particlesOptions.shape.close;\n    this.options = particlesOptions;\n    const pathOptions = this.options.move.path;\n    this.pathDelay = getValue(pathOptions.delay) * 1000;\n\n    if (pathOptions.generator) {\n      this.pathGenerator = this._engine.plugins.getPathGenerator(pathOptions.generator);\n\n      if (this.pathGenerator && container.addPath(pathOptions.generator, this.pathGenerator)) {\n        this.pathGenerator.init(container);\n      }\n    }\n\n    container.retina.initParticle(this);\n    this.size = initParticleNumericAnimationValue(this.options.size, pxRatio);\n    this.bubble = {\n      inRange: false\n    };\n    this.slow = {\n      inRange: false,\n      factor: 1\n    };\n\n    this._initPosition(position);\n\n    this.initialVelocity = this._calculateVelocity();\n    this.velocity = this.initialVelocity.copy();\n    this.moveDecay = 1 - getRangeValue(this.options.move.decay);\n    const particles = container.particles;\n    particles.needsSort = particles.needsSort || particles.lastZIndex < this.position.z;\n    particles.lastZIndex = this.position.z;\n    this.zIndexFactor = this.position.z / container.zLayers;\n    this.sides = 24;\n    let drawer = container.drawers.get(this.shape);\n\n    if (!drawer) {\n      drawer = this._engine.plugins.getShapeDrawer(this.shape);\n\n      if (drawer) {\n        container.drawers.set(this.shape, drawer);\n      }\n    }\n\n    if (drawer && drawer.loadShape) {\n      drawer.loadShape(this);\n    }\n\n    const sideCountFunc = drawer?.getSidesCount;\n\n    if (sideCountFunc) {\n      this.sides = sideCountFunc(this);\n    }\n\n    this.spawning = false;\n    this.shadowColor = rangeColorToRgb(this.options.shadow.color);\n\n    for (const updater of container.particles.updaters) {\n      updater.init(this);\n    }\n\n    for (const mover of container.particles.movers) {\n      mover.init && mover.init(this);\n    }\n\n    if (drawer && drawer.particleInit) {\n      drawer.particleInit(container, this);\n    }\n\n    for (const [, plugin] of container.plugins) {\n      plugin.particleCreated && plugin.particleCreated(this);\n    }\n  }\n\n  isInsideCanvas() {\n    const radius = this.getRadius(),\n          canvasSize = this.container.canvas.size,\n          position = this.position;\n    return position.x >= -radius && position.y >= -radius && position.y <= canvasSize.height + radius && position.x <= canvasSize.width + radius;\n  }\n\n  isVisible() {\n    return !this.destroyed && !this.spawning && this.isInsideCanvas();\n  }\n\n  reset() {\n    for (const updater of this.container.particles.updaters) {\n      updater.reset && updater.reset(this);\n    }\n  }\n\n}","map":{"version":3,"names":["calcExactPositionOrRandomFromSize","clamp","getDistance","getParticleBaseVelocity","getParticleDirectionAngle","getRandom","getRangeValue","getValue","randomInRange","setRangeValue","deepExtend","getPosition","initParticleNumericAnimationValue","isInArray","itemFromSingleOrMultiple","getHslFromAnimation","rangeColorToRgb","Interactivity","Vector","Vector3d","alterHsl","errorPrefix","loadParticlesOptions","fixOutMode","data","outMode","checkModes","diameter","radius","coord","maxCoord","setCb","Particle","constructor","engine","id","container","position","overrideOptions","group","_calcPosition","zIndex","tryCount","plugin","plugins","pluginPos","particlePosition","undefined","create","x","y","canvasSize","canvas","size","exactPosition","pos","getRadius","outModes","options","move","fixHorizontal","width","value","fixVertical","height","left","default","right","top","bottom","_checkOverlap","_calculateVelocity","baseVelocity","direction","res","copy","moveOptions","rad","Math","PI","angle","radOffset","offset","range","straight","random","speed","length","collisionsOptions","collisions","enable","overlapOptions","overlap","retries","Error","particles","find","particle","_getRollColor","color","roll","backColor","alter","backFactor","horizontal","vertical","backSum","rolled","floor","type","_initPosition","zIndexValue","zLayers","initialPosition","moveCenter","center","mode","outType","origin","_loadShapeData","shapeOptions","reduceDuplicates","shapeData","shape","close","fill","_engine","init","destroy","override","unbreakable","destroyed","bubble","inRange","slow","pathGenerator","particleDestroyed","updater","updaters","reset","draw","delta","drawParticlePlugin","drawParticle","getFillColor","getMass","z","getStrokeColor","strokeColor","pathRotation","lastPathTime","rotation","misplaced","retina","maxDistance","ignoresResizeRatio","pxRatio","pixelRatio","mainOptions","actualOptions","particlesOptions","shapeType","overrideShapeType","load","interactivity","pathOptions","path","pathDelay","delay","generator","getPathGenerator","addPath","initParticle","factor","initialVelocity","velocity","moveDecay","decay","needsSort","lastZIndex","zIndexFactor","sides","drawer","drawers","get","getShapeDrawer","set","loadShape","sideCountFunc","getSidesCount","spawning","shadowColor","shadow","mover","movers","particleInit","particleCreated","isInsideCanvas","isVisible"],"sources":["/Users/mohammedhusain/myportfolio/node_modules/tsparticles-engine/esm/Core/Particle.js"],"sourcesContent":["import { calcExactPositionOrRandomFromSize, clamp, getDistance, getParticleBaseVelocity, getParticleDirectionAngle, getRandom, getRangeValue, getValue, randomInRange, setRangeValue, } from \"../Utils/NumberUtils\";\nimport { deepExtend, getPosition, initParticleNumericAnimationValue, isInArray, itemFromSingleOrMultiple, } from \"../Utils/Utils\";\nimport { getHslFromAnimation, rangeColorToRgb } from \"../Utils/ColorUtils\";\nimport { Interactivity } from \"../Options/Classes/Interactivity/Interactivity\";\nimport { Vector } from \"./Utils/Vector\";\nimport { Vector3d } from \"./Utils/Vector3d\";\nimport { alterHsl } from \"../Utils/CanvasUtils\";\nimport { errorPrefix } from \"./Utils/Constants\";\nimport { loadParticlesOptions } from \"../Utils/OptionsUtils\";\nconst fixOutMode = (data) => {\n    if (!isInArray(data.outMode, data.checkModes)) {\n        return;\n    }\n    const diameter = data.radius * 2;\n    if (data.coord > data.maxCoord - diameter) {\n        data.setCb(-data.radius);\n    }\n    else if (data.coord < diameter) {\n        data.setCb(data.radius);\n    }\n};\nexport class Particle {\n    constructor(engine, id, container, position, overrideOptions, group) {\n        this.container = container;\n        this._calcPosition = (container, position, zIndex, tryCount = 0) => {\n            for (const [, plugin] of container.plugins) {\n                const pluginPos = plugin.particlePosition !== undefined ? plugin.particlePosition(position, this) : undefined;\n                if (pluginPos) {\n                    return Vector3d.create(pluginPos.x, pluginPos.y, zIndex);\n                }\n            }\n            const canvasSize = container.canvas.size, exactPosition = calcExactPositionOrRandomFromSize({\n                size: canvasSize,\n                position: position,\n            }), pos = Vector3d.create(exactPosition.x, exactPosition.y, zIndex), radius = this.getRadius(), outModes = this.options.move.outModes, fixHorizontal = (outMode) => {\n                fixOutMode({\n                    outMode,\n                    checkModes: [\"bounce\", \"bounce-horizontal\"],\n                    coord: pos.x,\n                    maxCoord: container.canvas.size.width,\n                    setCb: (value) => (pos.x += value),\n                    radius,\n                });\n            }, fixVertical = (outMode) => {\n                fixOutMode({\n                    outMode,\n                    checkModes: [\"bounce\", \"bounce-vertical\"],\n                    coord: pos.y,\n                    maxCoord: container.canvas.size.height,\n                    setCb: (value) => (pos.y += value),\n                    radius,\n                });\n            };\n            fixHorizontal(outModes.left ?? outModes.default);\n            fixHorizontal(outModes.right ?? outModes.default);\n            fixVertical(outModes.top ?? outModes.default);\n            fixVertical(outModes.bottom ?? outModes.default);\n            if (this._checkOverlap(pos, tryCount)) {\n                return this._calcPosition(container, undefined, zIndex, tryCount + 1);\n            }\n            return pos;\n        };\n        this._calculateVelocity = () => {\n            const baseVelocity = getParticleBaseVelocity(this.direction), res = baseVelocity.copy(), moveOptions = this.options.move;\n            if (moveOptions.direction === \"inside\" || moveOptions.direction === \"outside\") {\n                return res;\n            }\n            const rad = (Math.PI / 180) * getRangeValue(moveOptions.angle.value), radOffset = (Math.PI / 180) * getRangeValue(moveOptions.angle.offset), range = {\n                left: radOffset - rad / 2,\n                right: radOffset + rad / 2,\n            };\n            if (!moveOptions.straight) {\n                res.angle += randomInRange(setRangeValue(range.left, range.right));\n            }\n            if (moveOptions.random && typeof moveOptions.speed === \"number\") {\n                res.length *= getRandom();\n            }\n            return res;\n        };\n        this._checkOverlap = (pos, tryCount = 0) => {\n            const collisionsOptions = this.options.collisions, radius = this.getRadius();\n            if (!collisionsOptions.enable) {\n                return false;\n            }\n            const overlapOptions = collisionsOptions.overlap;\n            if (overlapOptions.enable) {\n                return false;\n            }\n            const retries = overlapOptions.retries;\n            if (retries >= 0 && tryCount > retries) {\n                throw new Error(`${errorPrefix} particle is overlapping and can't be placed`);\n            }\n            return !!this.container.particles.find((particle) => getDistance(pos, particle.position) < radius + particle.getRadius());\n        };\n        this._getRollColor = (color) => {\n            if (!color || !this.roll || (!this.backColor && !this.roll.alter)) {\n                return color;\n            }\n            const backFactor = this.roll.horizontal && this.roll.vertical ? 2 : 1, backSum = this.roll.horizontal ? Math.PI / 2 : 0, rolled = Math.floor(((this.roll.angle ?? 0) + backSum) / (Math.PI / backFactor)) % 2;\n            if (!rolled) {\n                return color;\n            }\n            if (this.backColor) {\n                return this.backColor;\n            }\n            if (this.roll.alter) {\n                return alterHsl(color, this.roll.alter.type, this.roll.alter.value);\n            }\n            return color;\n        };\n        this._initPosition = (position) => {\n            const container = this.container, zIndexValue = getRangeValue(this.options.zIndex.value);\n            this.position = this._calcPosition(container, position, clamp(zIndexValue, 0, container.zLayers));\n            this.initialPosition = this.position.copy();\n            const canvasSize = container.canvas.size;\n            this.moveCenter = {\n                ...getPosition(this.options.move.center, canvasSize),\n                radius: this.options.move.center.radius ?? 0,\n                mode: this.options.move.center.mode ?? \"percent\",\n            };\n            this.direction = getParticleDirectionAngle(this.options.move.direction, this.position, this.moveCenter);\n            switch (this.options.move.direction) {\n                case \"inside\":\n                    this.outType = \"inside\";\n                    break;\n                case \"outside\":\n                    this.outType = \"outside\";\n                    break;\n            }\n            this.offset = Vector.origin;\n        };\n        this._loadShapeData = (shapeOptions, reduceDuplicates) => {\n            const shapeData = shapeOptions.options[this.shape];\n            if (!shapeData) {\n                return;\n            }\n            return deepExtend({\n                close: shapeOptions.close,\n                fill: shapeOptions.fill,\n            }, itemFromSingleOrMultiple(shapeData, this.id, reduceDuplicates));\n        };\n        this._engine = engine;\n        this.init(id, position, overrideOptions, group);\n    }\n    destroy(override) {\n        if (this.unbreakable || this.destroyed) {\n            return;\n        }\n        this.destroyed = true;\n        this.bubble.inRange = false;\n        this.slow.inRange = false;\n        const container = this.container, pathGenerator = this.pathGenerator;\n        for (const [, plugin] of container.plugins) {\n            if (plugin.particleDestroyed) {\n                plugin.particleDestroyed(this, override);\n            }\n        }\n        for (const updater of container.particles.updaters) {\n            if (updater.particleDestroyed) {\n                updater.particleDestroyed(this, override);\n            }\n        }\n        if (pathGenerator) {\n            pathGenerator.reset(this);\n        }\n    }\n    draw(delta) {\n        const container = this.container;\n        for (const [, plugin] of container.plugins) {\n            container.canvas.drawParticlePlugin(plugin, this, delta);\n        }\n        container.canvas.drawParticle(this, delta);\n    }\n    getFillColor() {\n        return this._getRollColor(this.bubble.color ?? getHslFromAnimation(this.color));\n    }\n    getMass() {\n        return (this.getRadius() ** 2 * Math.PI) / 2;\n    }\n    getPosition() {\n        return {\n            x: this.position.x + this.offset.x,\n            y: this.position.y + this.offset.y,\n            z: this.position.z,\n        };\n    }\n    getRadius() {\n        return this.bubble.radius ?? this.size.value;\n    }\n    getStrokeColor() {\n        return this._getRollColor(this.bubble.color ?? getHslFromAnimation(this.strokeColor));\n    }\n    init(id, position, overrideOptions, group) {\n        const container = this.container, engine = this._engine;\n        this.id = id;\n        this.group = group;\n        this.fill = true;\n        this.pathRotation = false;\n        this.close = true;\n        this.lastPathTime = 0;\n        this.destroyed = false;\n        this.unbreakable = false;\n        this.rotation = 0;\n        this.misplaced = false;\n        this.retina = {\n            maxDistance: {},\n        };\n        this.outType = \"normal\";\n        this.ignoresResizeRatio = true;\n        const pxRatio = container.retina.pixelRatio, mainOptions = container.actualOptions, particlesOptions = loadParticlesOptions(this._engine, container, mainOptions.particles), shapeType = particlesOptions.shape.type, { reduceDuplicates } = particlesOptions;\n        this.shape = itemFromSingleOrMultiple(shapeType, this.id, reduceDuplicates);\n        const shapeOptions = particlesOptions.shape;\n        if (overrideOptions && overrideOptions.shape && overrideOptions.shape.type) {\n            const overrideShapeType = overrideOptions.shape.type, shape = itemFromSingleOrMultiple(overrideShapeType, this.id, reduceDuplicates);\n            if (shape) {\n                this.shape = shape;\n                shapeOptions.load(overrideOptions.shape);\n            }\n        }\n        this.shapeData = this._loadShapeData(shapeOptions, reduceDuplicates);\n        particlesOptions.load(overrideOptions);\n        const shapeData = this.shapeData;\n        if (shapeData) {\n            particlesOptions.load(shapeData.particles);\n        }\n        const interactivity = new Interactivity(engine, container);\n        interactivity.load(container.actualOptions.interactivity);\n        interactivity.load(particlesOptions.interactivity);\n        this.interactivity = interactivity;\n        this.fill = shapeData?.fill ?? particlesOptions.shape.fill;\n        this.close = shapeData?.close ?? particlesOptions.shape.close;\n        this.options = particlesOptions;\n        const pathOptions = this.options.move.path;\n        this.pathDelay = getValue(pathOptions.delay) * 1000;\n        if (pathOptions.generator) {\n            this.pathGenerator = this._engine.plugins.getPathGenerator(pathOptions.generator);\n            if (this.pathGenerator && container.addPath(pathOptions.generator, this.pathGenerator)) {\n                this.pathGenerator.init(container);\n            }\n        }\n        container.retina.initParticle(this);\n        this.size = initParticleNumericAnimationValue(this.options.size, pxRatio);\n        this.bubble = {\n            inRange: false,\n        };\n        this.slow = {\n            inRange: false,\n            factor: 1,\n        };\n        this._initPosition(position);\n        this.initialVelocity = this._calculateVelocity();\n        this.velocity = this.initialVelocity.copy();\n        this.moveDecay = 1 - getRangeValue(this.options.move.decay);\n        const particles = container.particles;\n        particles.needsSort = particles.needsSort || particles.lastZIndex < this.position.z;\n        particles.lastZIndex = this.position.z;\n        this.zIndexFactor = this.position.z / container.zLayers;\n        this.sides = 24;\n        let drawer = container.drawers.get(this.shape);\n        if (!drawer) {\n            drawer = this._engine.plugins.getShapeDrawer(this.shape);\n            if (drawer) {\n                container.drawers.set(this.shape, drawer);\n            }\n        }\n        if (drawer && drawer.loadShape) {\n            drawer.loadShape(this);\n        }\n        const sideCountFunc = drawer?.getSidesCount;\n        if (sideCountFunc) {\n            this.sides = sideCountFunc(this);\n        }\n        this.spawning = false;\n        this.shadowColor = rangeColorToRgb(this.options.shadow.color);\n        for (const updater of container.particles.updaters) {\n            updater.init(this);\n        }\n        for (const mover of container.particles.movers) {\n            mover.init && mover.init(this);\n        }\n        if (drawer && drawer.particleInit) {\n            drawer.particleInit(container, this);\n        }\n        for (const [, plugin] of container.plugins) {\n            plugin.particleCreated && plugin.particleCreated(this);\n        }\n    }\n    isInsideCanvas() {\n        const radius = this.getRadius(), canvasSize = this.container.canvas.size, position = this.position;\n        return (position.x >= -radius &&\n            position.y >= -radius &&\n            position.y <= canvasSize.height + radius &&\n            position.x <= canvasSize.width + radius);\n    }\n    isVisible() {\n        return !this.destroyed && !this.spawning && this.isInsideCanvas();\n    }\n    reset() {\n        for (const updater of this.container.particles.updaters) {\n            updater.reset && updater.reset(this);\n        }\n    }\n}\n"],"mappings":"AAAA,SAASA,iCAAT,EAA4CC,KAA5C,EAAmDC,WAAnD,EAAgEC,uBAAhE,EAAyFC,yBAAzF,EAAoHC,SAApH,EAA+HC,aAA/H,EAA8IC,QAA9I,EAAwJC,aAAxJ,EAAuKC,aAAvK,QAA6L,sBAA7L;AACA,SAASC,UAAT,EAAqBC,WAArB,EAAkCC,iCAAlC,EAAqEC,SAArE,EAAgFC,wBAAhF,QAAiH,gBAAjH;AACA,SAASC,mBAAT,EAA8BC,eAA9B,QAAqD,qBAArD;AACA,SAASC,aAAT,QAA8B,gDAA9B;AACA,SAASC,MAAT,QAAuB,gBAAvB;AACA,SAASC,QAAT,QAAyB,kBAAzB;AACA,SAASC,QAAT,QAAyB,sBAAzB;AACA,SAASC,WAAT,QAA4B,mBAA5B;AACA,SAASC,oBAAT,QAAqC,uBAArC;;AACA,MAAMC,UAAU,GAAIC,IAAD,IAAU;EACzB,IAAI,CAACX,SAAS,CAACW,IAAI,CAACC,OAAN,EAAeD,IAAI,CAACE,UAApB,CAAd,EAA+C;IAC3C;EACH;;EACD,MAAMC,QAAQ,GAAGH,IAAI,CAACI,MAAL,GAAc,CAA/B;;EACA,IAAIJ,IAAI,CAACK,KAAL,GAAaL,IAAI,CAACM,QAAL,GAAgBH,QAAjC,EAA2C;IACvCH,IAAI,CAACO,KAAL,CAAW,CAACP,IAAI,CAACI,MAAjB;EACH,CAFD,MAGK,IAAIJ,IAAI,CAACK,KAAL,GAAaF,QAAjB,EAA2B;IAC5BH,IAAI,CAACO,KAAL,CAAWP,IAAI,CAACI,MAAhB;EACH;AACJ,CAXD;;AAYA,OAAO,MAAMI,QAAN,CAAe;EAClBC,WAAW,CAACC,MAAD,EAASC,EAAT,EAAaC,SAAb,EAAwBC,QAAxB,EAAkCC,eAAlC,EAAmDC,KAAnD,EAA0D;IAAA;;IACjE,KAAKH,SAAL,GAAiBA,SAAjB;;IACA,KAAKI,aAAL,GAAqB,UAACJ,SAAD,EAAYC,QAAZ,EAAsBI,MAAtB,EAA+C;MAAA,IAAjBC,QAAiB,uEAAN,CAAM;;MAChE,KAAK,MAAM,GAAGC,MAAH,CAAX,IAAyBP,SAAS,CAACQ,OAAnC,EAA4C;QACxC,MAAMC,SAAS,GAAGF,MAAM,CAACG,gBAAP,KAA4BC,SAA5B,GAAwCJ,MAAM,CAACG,gBAAP,CAAwBT,QAAxB,EAAkC,KAAlC,CAAxC,GAAkFU,SAApG;;QACA,IAAIF,SAAJ,EAAe;UACX,OAAO1B,QAAQ,CAAC6B,MAAT,CAAgBH,SAAS,CAACI,CAA1B,EAA6BJ,SAAS,CAACK,CAAvC,EAA0CT,MAA1C,CAAP;QACH;MACJ;;MACD,MAAMU,UAAU,GAAGf,SAAS,CAACgB,MAAV,CAAiBC,IAApC;MAAA,MAA0CC,aAAa,GAAGtD,iCAAiC,CAAC;QACxFqD,IAAI,EAAEF,UADkF;QAExFd,QAAQ,EAAEA;MAF8E,CAAD,CAA3F;MAAA,MAGIkB,GAAG,GAAGpC,QAAQ,CAAC6B,MAAT,CAAgBM,aAAa,CAACL,CAA9B,EAAiCK,aAAa,CAACJ,CAA/C,EAAkDT,MAAlD,CAHV;MAAA,MAGqEb,MAAM,GAAG,KAAI,CAAC4B,SAAL,EAH9E;MAAA,MAGgGC,QAAQ,GAAG,KAAI,CAACC,OAAL,CAAaC,IAAb,CAAkBF,QAH7H;MAAA,MAGuIG,aAAa,GAAInC,OAAD,IAAa;QAChKF,UAAU,CAAC;UACPE,OADO;UAEPC,UAAU,EAAE,CAAC,QAAD,EAAW,mBAAX,CAFL;UAGPG,KAAK,EAAE0B,GAAG,CAACN,CAHJ;UAIPnB,QAAQ,EAAEM,SAAS,CAACgB,MAAV,CAAiBC,IAAjB,CAAsBQ,KAJzB;UAKP9B,KAAK,EAAG+B,KAAD,IAAYP,GAAG,CAACN,CAAJ,IAASa,KALrB;UAMPlC;QANO,CAAD,CAAV;MAQH,CAZD;MAAA,MAYGmC,WAAW,GAAItC,OAAD,IAAa;QAC1BF,UAAU,CAAC;UACPE,OADO;UAEPC,UAAU,EAAE,CAAC,QAAD,EAAW,iBAAX,CAFL;UAGPG,KAAK,EAAE0B,GAAG,CAACL,CAHJ;UAIPpB,QAAQ,EAAEM,SAAS,CAACgB,MAAV,CAAiBC,IAAjB,CAAsBW,MAJzB;UAKPjC,KAAK,EAAG+B,KAAD,IAAYP,GAAG,CAACL,CAAJ,IAASY,KALrB;UAMPlC;QANO,CAAD,CAAV;MAQH,CArBD;;MAsBAgC,aAAa,CAACH,QAAQ,CAACQ,IAAT,IAAiBR,QAAQ,CAACS,OAA3B,CAAb;MACAN,aAAa,CAACH,QAAQ,CAACU,KAAT,IAAkBV,QAAQ,CAACS,OAA5B,CAAb;MACAH,WAAW,CAACN,QAAQ,CAACW,GAAT,IAAgBX,QAAQ,CAACS,OAA1B,CAAX;MACAH,WAAW,CAACN,QAAQ,CAACY,MAAT,IAAmBZ,QAAQ,CAACS,OAA7B,CAAX;;MACA,IAAI,KAAI,CAACI,aAAL,CAAmBf,GAAnB,EAAwBb,QAAxB,CAAJ,EAAuC;QACnC,OAAO,KAAI,CAACF,aAAL,CAAmBJ,SAAnB,EAA8BW,SAA9B,EAAyCN,MAAzC,EAAiDC,QAAQ,GAAG,CAA5D,CAAP;MACH;;MACD,OAAOa,GAAP;IACH,CArCD;;IAsCA,KAAKgB,kBAAL,GAA0B,MAAM;MAC5B,MAAMC,YAAY,GAAGrE,uBAAuB,CAAC,KAAKsE,SAAN,CAA5C;MAAA,MAA8DC,GAAG,GAAGF,YAAY,CAACG,IAAb,EAApE;MAAA,MAAyFC,WAAW,GAAG,KAAKlB,OAAL,CAAaC,IAApH;;MACA,IAAIiB,WAAW,CAACH,SAAZ,KAA0B,QAA1B,IAAsCG,WAAW,CAACH,SAAZ,KAA0B,SAApE,EAA+E;QAC3E,OAAOC,GAAP;MACH;;MACD,MAAMG,GAAG,GAAIC,IAAI,CAACC,EAAL,GAAU,GAAX,GAAkBzE,aAAa,CAACsE,WAAW,CAACI,KAAZ,CAAkBlB,KAAnB,CAA3C;MAAA,MAAsEmB,SAAS,GAAIH,IAAI,CAACC,EAAL,GAAU,GAAX,GAAkBzE,aAAa,CAACsE,WAAW,CAACI,KAAZ,CAAkBE,MAAnB,CAAjH;MAAA,MAA6IC,KAAK,GAAG;QACjJlB,IAAI,EAAEgB,SAAS,GAAGJ,GAAG,GAAG,CADyH;QAEjJV,KAAK,EAAEc,SAAS,GAAGJ,GAAG,GAAG;MAFwH,CAArJ;;MAIA,IAAI,CAACD,WAAW,CAACQ,QAAjB,EAA2B;QACvBV,GAAG,CAACM,KAAJ,IAAaxE,aAAa,CAACC,aAAa,CAAC0E,KAAK,CAAClB,IAAP,EAAakB,KAAK,CAAChB,KAAnB,CAAd,CAA1B;MACH;;MACD,IAAIS,WAAW,CAACS,MAAZ,IAAsB,OAAOT,WAAW,CAACU,KAAnB,KAA6B,QAAvD,EAAiE;QAC7DZ,GAAG,CAACa,MAAJ,IAAclF,SAAS,EAAvB;MACH;;MACD,OAAOqE,GAAP;IACH,CAhBD;;IAiBA,KAAKJ,aAAL,GAAqB,UAACf,GAAD,EAAuB;MAAA,IAAjBb,QAAiB,uEAAN,CAAM;;MACxC,MAAM8C,iBAAiB,GAAG,KAAI,CAAC9B,OAAL,CAAa+B,UAAvC;MAAA,MAAmD7D,MAAM,GAAG,KAAI,CAAC4B,SAAL,EAA5D;;MACA,IAAI,CAACgC,iBAAiB,CAACE,MAAvB,EAA+B;QAC3B,OAAO,KAAP;MACH;;MACD,MAAMC,cAAc,GAAGH,iBAAiB,CAACI,OAAzC;;MACA,IAAID,cAAc,CAACD,MAAnB,EAA2B;QACvB,OAAO,KAAP;MACH;;MACD,MAAMG,OAAO,GAAGF,cAAc,CAACE,OAA/B;;MACA,IAAIA,OAAO,IAAI,CAAX,IAAgBnD,QAAQ,GAAGmD,OAA/B,EAAwC;QACpC,MAAM,IAAIC,KAAJ,CAAW,GAAEzE,WAAY,8CAAzB,CAAN;MACH;;MACD,OAAO,CAAC,CAAC,KAAI,CAACe,SAAL,CAAe2D,SAAf,CAAyBC,IAAzB,CAA+BC,QAAD,IAAc/F,WAAW,CAACqD,GAAD,EAAM0C,QAAQ,CAAC5D,QAAf,CAAX,GAAsCT,MAAM,GAAGqE,QAAQ,CAACzC,SAAT,EAA3F,CAAT;IACH,CAdD;;IAeA,KAAK0C,aAAL,GAAsBC,KAAD,IAAW;MAC5B,IAAI,CAACA,KAAD,IAAU,CAAC,KAAKC,IAAhB,IAAyB,CAAC,KAAKC,SAAN,IAAmB,CAAC,KAAKD,IAAL,CAAUE,KAA3D,EAAmE;QAC/D,OAAOH,KAAP;MACH;;MACD,MAAMI,UAAU,GAAG,KAAKH,IAAL,CAAUI,UAAV,IAAwB,KAAKJ,IAAL,CAAUK,QAAlC,GAA6C,CAA7C,GAAiD,CAApE;MAAA,MAAuEC,OAAO,GAAG,KAAKN,IAAL,CAAUI,UAAV,GAAuB1B,IAAI,CAACC,EAAL,GAAU,CAAjC,GAAqC,CAAtH;MAAA,MAAyH4B,MAAM,GAAG7B,IAAI,CAAC8B,KAAL,CAAW,CAAC,CAAC,KAAKR,IAAL,CAAUpB,KAAV,IAAmB,CAApB,IAAyB0B,OAA1B,KAAsC5B,IAAI,CAACC,EAAL,GAAUwB,UAAhD,CAAX,IAA0E,CAA5M;;MACA,IAAI,CAACI,MAAL,EAAa;QACT,OAAOR,KAAP;MACH;;MACD,IAAI,KAAKE,SAAT,EAAoB;QAChB,OAAO,KAAKA,SAAZ;MACH;;MACD,IAAI,KAAKD,IAAL,CAAUE,KAAd,EAAqB;QACjB,OAAOlF,QAAQ,CAAC+E,KAAD,EAAQ,KAAKC,IAAL,CAAUE,KAAV,CAAgBO,IAAxB,EAA8B,KAAKT,IAAL,CAAUE,KAAV,CAAgBxC,KAA9C,CAAf;MACH;;MACD,OAAOqC,KAAP;IACH,CAfD;;IAgBA,KAAKW,aAAL,GAAsBzE,QAAD,IAAc;MAC/B,MAAMD,SAAS,GAAG,KAAKA,SAAvB;MAAA,MAAkC2E,WAAW,GAAGzG,aAAa,CAAC,KAAKoD,OAAL,CAAajB,MAAb,CAAoBqB,KAArB,CAA7D;MACA,KAAKzB,QAAL,GAAgB,KAAKG,aAAL,CAAmBJ,SAAnB,EAA8BC,QAA9B,EAAwCpC,KAAK,CAAC8G,WAAD,EAAc,CAAd,EAAiB3E,SAAS,CAAC4E,OAA3B,CAA7C,CAAhB;MACA,KAAKC,eAAL,GAAuB,KAAK5E,QAAL,CAAcsC,IAAd,EAAvB;MACA,MAAMxB,UAAU,GAAGf,SAAS,CAACgB,MAAV,CAAiBC,IAApC;MACA,KAAK6D,UAAL,GAAkB,EACd,GAAGvG,WAAW,CAAC,KAAK+C,OAAL,CAAaC,IAAb,CAAkBwD,MAAnB,EAA2BhE,UAA3B,CADA;QAEdvB,MAAM,EAAE,KAAK8B,OAAL,CAAaC,IAAb,CAAkBwD,MAAlB,CAAyBvF,MAAzB,IAAmC,CAF7B;QAGdwF,IAAI,EAAE,KAAK1D,OAAL,CAAaC,IAAb,CAAkBwD,MAAlB,CAAyBC,IAAzB,IAAiC;MAHzB,CAAlB;MAKA,KAAK3C,SAAL,GAAiBrE,yBAAyB,CAAC,KAAKsD,OAAL,CAAaC,IAAb,CAAkBc,SAAnB,EAA8B,KAAKpC,QAAnC,EAA6C,KAAK6E,UAAlD,CAA1C;;MACA,QAAQ,KAAKxD,OAAL,CAAaC,IAAb,CAAkBc,SAA1B;QACI,KAAK,QAAL;UACI,KAAK4C,OAAL,GAAe,QAAf;UACA;;QACJ,KAAK,SAAL;UACI,KAAKA,OAAL,GAAe,SAAf;UACA;MANR;;MAQA,KAAKnC,MAAL,GAAchE,MAAM,CAACoG,MAArB;IACH,CApBD;;IAqBA,KAAKC,cAAL,GAAsB,CAACC,YAAD,EAAeC,gBAAf,KAAoC;MACtD,MAAMC,SAAS,GAAGF,YAAY,CAAC9D,OAAb,CAAqB,KAAKiE,KAA1B,CAAlB;;MACA,IAAI,CAACD,SAAL,EAAgB;QACZ;MACH;;MACD,OAAOhH,UAAU,CAAC;QACdkH,KAAK,EAAEJ,YAAY,CAACI,KADN;QAEdC,IAAI,EAAEL,YAAY,CAACK;MAFL,CAAD,EAGd/G,wBAAwB,CAAC4G,SAAD,EAAY,KAAKvF,EAAjB,EAAqBsF,gBAArB,CAHV,CAAjB;IAIH,CATD;;IAUA,KAAKK,OAAL,GAAe5F,MAAf;IACA,KAAK6F,IAAL,CAAU5F,EAAV,EAAcE,QAAd,EAAwBC,eAAxB,EAAyCC,KAAzC;EACH;;EACDyF,OAAO,CAACC,QAAD,EAAW;IACd,IAAI,KAAKC,WAAL,IAAoB,KAAKC,SAA7B,EAAwC;MACpC;IACH;;IACD,KAAKA,SAAL,GAAiB,IAAjB;IACA,KAAKC,MAAL,CAAYC,OAAZ,GAAsB,KAAtB;IACA,KAAKC,IAAL,CAAUD,OAAV,GAAoB,KAApB;IACA,MAAMjG,SAAS,GAAG,KAAKA,SAAvB;IAAA,MAAkCmG,aAAa,GAAG,KAAKA,aAAvD;;IACA,KAAK,MAAM,GAAG5F,MAAH,CAAX,IAAyBP,SAAS,CAACQ,OAAnC,EAA4C;MACxC,IAAID,MAAM,CAAC6F,iBAAX,EAA8B;QAC1B7F,MAAM,CAAC6F,iBAAP,CAAyB,IAAzB,EAA+BP,QAA/B;MACH;IACJ;;IACD,KAAK,MAAMQ,OAAX,IAAsBrG,SAAS,CAAC2D,SAAV,CAAoB2C,QAA1C,EAAoD;MAChD,IAAID,OAAO,CAACD,iBAAZ,EAA+B;QAC3BC,OAAO,CAACD,iBAAR,CAA0B,IAA1B,EAAgCP,QAAhC;MACH;IACJ;;IACD,IAAIM,aAAJ,EAAmB;MACfA,aAAa,CAACI,KAAd,CAAoB,IAApB;IACH;EACJ;;EACDC,IAAI,CAACC,KAAD,EAAQ;IACR,MAAMzG,SAAS,GAAG,KAAKA,SAAvB;;IACA,KAAK,MAAM,GAAGO,MAAH,CAAX,IAAyBP,SAAS,CAACQ,OAAnC,EAA4C;MACxCR,SAAS,CAACgB,MAAV,CAAiB0F,kBAAjB,CAAoCnG,MAApC,EAA4C,IAA5C,EAAkDkG,KAAlD;IACH;;IACDzG,SAAS,CAACgB,MAAV,CAAiB2F,YAAjB,CAA8B,IAA9B,EAAoCF,KAApC;EACH;;EACDG,YAAY,GAAG;IACX,OAAO,KAAK9C,aAAL,CAAmB,KAAKkC,MAAL,CAAYjC,KAAZ,IAAqBpF,mBAAmB,CAAC,KAAKoF,KAAN,CAA3D,CAAP;EACH;;EACD8C,OAAO,GAAG;IACN,OAAQ,KAAKzF,SAAL,MAAoB,CAApB,GAAwBsB,IAAI,CAACC,EAA9B,GAAoC,CAA3C;EACH;;EACDpE,WAAW,GAAG;IACV,OAAO;MACHsC,CAAC,EAAE,KAAKZ,QAAL,CAAcY,CAAd,GAAkB,KAAKiC,MAAL,CAAYjC,CAD9B;MAEHC,CAAC,EAAE,KAAKb,QAAL,CAAca,CAAd,GAAkB,KAAKgC,MAAL,CAAYhC,CAF9B;MAGHgG,CAAC,EAAE,KAAK7G,QAAL,CAAc6G;IAHd,CAAP;EAKH;;EACD1F,SAAS,GAAG;IACR,OAAO,KAAK4E,MAAL,CAAYxG,MAAZ,IAAsB,KAAKyB,IAAL,CAAUS,KAAvC;EACH;;EACDqF,cAAc,GAAG;IACb,OAAO,KAAKjD,aAAL,CAAmB,KAAKkC,MAAL,CAAYjC,KAAZ,IAAqBpF,mBAAmB,CAAC,KAAKqI,WAAN,CAA3D,CAAP;EACH;;EACDrB,IAAI,CAAC5F,EAAD,EAAKE,QAAL,EAAeC,eAAf,EAAgCC,KAAhC,EAAuC;IACvC,MAAMH,SAAS,GAAG,KAAKA,SAAvB;IAAA,MAAkCF,MAAM,GAAG,KAAK4F,OAAhD;IACA,KAAK3F,EAAL,GAAUA,EAAV;IACA,KAAKI,KAAL,GAAaA,KAAb;IACA,KAAKsF,IAAL,GAAY,IAAZ;IACA,KAAKwB,YAAL,GAAoB,KAApB;IACA,KAAKzB,KAAL,GAAa,IAAb;IACA,KAAK0B,YAAL,GAAoB,CAApB;IACA,KAAKnB,SAAL,GAAiB,KAAjB;IACA,KAAKD,WAAL,GAAmB,KAAnB;IACA,KAAKqB,QAAL,GAAgB,CAAhB;IACA,KAAKC,SAAL,GAAiB,KAAjB;IACA,KAAKC,MAAL,GAAc;MACVC,WAAW,EAAE;IADH,CAAd;IAGA,KAAKrC,OAAL,GAAe,QAAf;IACA,KAAKsC,kBAAL,GAA0B,IAA1B;IACA,MAAMC,OAAO,GAAGxH,SAAS,CAACqH,MAAV,CAAiBI,UAAjC;IAAA,MAA6CC,WAAW,GAAG1H,SAAS,CAAC2H,aAArE;IAAA,MAAoFC,gBAAgB,GAAG1I,oBAAoB,CAAC,KAAKwG,OAAN,EAAe1F,SAAf,EAA0B0H,WAAW,CAAC/D,SAAtC,CAA3H;IAAA,MAA6KkE,SAAS,GAAGD,gBAAgB,CAACrC,KAAjB,CAAuBd,IAAhN;IAAA,MAAsN;MAAEY;IAAF,IAAuBuC,gBAA7O;IACA,KAAKrC,KAAL,GAAa7G,wBAAwB,CAACmJ,SAAD,EAAY,KAAK9H,EAAjB,EAAqBsF,gBAArB,CAArC;IACA,MAAMD,YAAY,GAAGwC,gBAAgB,CAACrC,KAAtC;;IACA,IAAIrF,eAAe,IAAIA,eAAe,CAACqF,KAAnC,IAA4CrF,eAAe,CAACqF,KAAhB,CAAsBd,IAAtE,EAA4E;MACxE,MAAMqD,iBAAiB,GAAG5H,eAAe,CAACqF,KAAhB,CAAsBd,IAAhD;MAAA,MAAsDc,KAAK,GAAG7G,wBAAwB,CAACoJ,iBAAD,EAAoB,KAAK/H,EAAzB,EAA6BsF,gBAA7B,CAAtF;;MACA,IAAIE,KAAJ,EAAW;QACP,KAAKA,KAAL,GAAaA,KAAb;QACAH,YAAY,CAAC2C,IAAb,CAAkB7H,eAAe,CAACqF,KAAlC;MACH;IACJ;;IACD,KAAKD,SAAL,GAAiB,KAAKH,cAAL,CAAoBC,YAApB,EAAkCC,gBAAlC,CAAjB;IACAuC,gBAAgB,CAACG,IAAjB,CAAsB7H,eAAtB;IACA,MAAMoF,SAAS,GAAG,KAAKA,SAAvB;;IACA,IAAIA,SAAJ,EAAe;MACXsC,gBAAgB,CAACG,IAAjB,CAAsBzC,SAAS,CAAC3B,SAAhC;IACH;;IACD,MAAMqE,aAAa,GAAG,IAAInJ,aAAJ,CAAkBiB,MAAlB,EAA0BE,SAA1B,CAAtB;IACAgI,aAAa,CAACD,IAAd,CAAmB/H,SAAS,CAAC2H,aAAV,CAAwBK,aAA3C;IACAA,aAAa,CAACD,IAAd,CAAmBH,gBAAgB,CAACI,aAApC;IACA,KAAKA,aAAL,GAAqBA,aAArB;IACA,KAAKvC,IAAL,GAAYH,SAAS,EAAEG,IAAX,IAAmBmC,gBAAgB,CAACrC,KAAjB,CAAuBE,IAAtD;IACA,KAAKD,KAAL,GAAaF,SAAS,EAAEE,KAAX,IAAoBoC,gBAAgB,CAACrC,KAAjB,CAAuBC,KAAxD;IACA,KAAKlE,OAAL,GAAesG,gBAAf;IACA,MAAMK,WAAW,GAAG,KAAK3G,OAAL,CAAaC,IAAb,CAAkB2G,IAAtC;IACA,KAAKC,SAAL,GAAiBhK,QAAQ,CAAC8J,WAAW,CAACG,KAAb,CAAR,GAA8B,IAA/C;;IACA,IAAIH,WAAW,CAACI,SAAhB,EAA2B;MACvB,KAAKlC,aAAL,GAAqB,KAAKT,OAAL,CAAalF,OAAb,CAAqB8H,gBAArB,CAAsCL,WAAW,CAACI,SAAlD,CAArB;;MACA,IAAI,KAAKlC,aAAL,IAAsBnG,SAAS,CAACuI,OAAV,CAAkBN,WAAW,CAACI,SAA9B,EAAyC,KAAKlC,aAA9C,CAA1B,EAAwF;QACpF,KAAKA,aAAL,CAAmBR,IAAnB,CAAwB3F,SAAxB;MACH;IACJ;;IACDA,SAAS,CAACqH,MAAV,CAAiBmB,YAAjB,CAA8B,IAA9B;IACA,KAAKvH,IAAL,GAAYzC,iCAAiC,CAAC,KAAK8C,OAAL,CAAaL,IAAd,EAAoBuG,OAApB,CAA7C;IACA,KAAKxB,MAAL,GAAc;MACVC,OAAO,EAAE;IADC,CAAd;IAGA,KAAKC,IAAL,GAAY;MACRD,OAAO,EAAE,KADD;MAERwC,MAAM,EAAE;IAFA,CAAZ;;IAIA,KAAK/D,aAAL,CAAmBzE,QAAnB;;IACA,KAAKyI,eAAL,GAAuB,KAAKvG,kBAAL,EAAvB;IACA,KAAKwG,QAAL,GAAgB,KAAKD,eAAL,CAAqBnG,IAArB,EAAhB;IACA,KAAKqG,SAAL,GAAiB,IAAI1K,aAAa,CAAC,KAAKoD,OAAL,CAAaC,IAAb,CAAkBsH,KAAnB,CAAlC;IACA,MAAMlF,SAAS,GAAG3D,SAAS,CAAC2D,SAA5B;IACAA,SAAS,CAACmF,SAAV,GAAsBnF,SAAS,CAACmF,SAAV,IAAuBnF,SAAS,CAACoF,UAAV,GAAuB,KAAK9I,QAAL,CAAc6G,CAAlF;IACAnD,SAAS,CAACoF,UAAV,GAAuB,KAAK9I,QAAL,CAAc6G,CAArC;IACA,KAAKkC,YAAL,GAAoB,KAAK/I,QAAL,CAAc6G,CAAd,GAAkB9G,SAAS,CAAC4E,OAAhD;IACA,KAAKqE,KAAL,GAAa,EAAb;IACA,IAAIC,MAAM,GAAGlJ,SAAS,CAACmJ,OAAV,CAAkBC,GAAlB,CAAsB,KAAK7D,KAA3B,CAAb;;IACA,IAAI,CAAC2D,MAAL,EAAa;MACTA,MAAM,GAAG,KAAKxD,OAAL,CAAalF,OAAb,CAAqB6I,cAArB,CAAoC,KAAK9D,KAAzC,CAAT;;MACA,IAAI2D,MAAJ,EAAY;QACRlJ,SAAS,CAACmJ,OAAV,CAAkBG,GAAlB,CAAsB,KAAK/D,KAA3B,EAAkC2D,MAAlC;MACH;IACJ;;IACD,IAAIA,MAAM,IAAIA,MAAM,CAACK,SAArB,EAAgC;MAC5BL,MAAM,CAACK,SAAP,CAAiB,IAAjB;IACH;;IACD,MAAMC,aAAa,GAAGN,MAAM,EAAEO,aAA9B;;IACA,IAAID,aAAJ,EAAmB;MACf,KAAKP,KAAL,GAAaO,aAAa,CAAC,IAAD,CAA1B;IACH;;IACD,KAAKE,QAAL,GAAgB,KAAhB;IACA,KAAKC,WAAL,GAAmB/K,eAAe,CAAC,KAAK0C,OAAL,CAAasI,MAAb,CAAoB7F,KAArB,CAAlC;;IACA,KAAK,MAAMsC,OAAX,IAAsBrG,SAAS,CAAC2D,SAAV,CAAoB2C,QAA1C,EAAoD;MAChDD,OAAO,CAACV,IAAR,CAAa,IAAb;IACH;;IACD,KAAK,MAAMkE,KAAX,IAAoB7J,SAAS,CAAC2D,SAAV,CAAoBmG,MAAxC,EAAgD;MAC5CD,KAAK,CAAClE,IAAN,IAAckE,KAAK,CAAClE,IAAN,CAAW,IAAX,CAAd;IACH;;IACD,IAAIuD,MAAM,IAAIA,MAAM,CAACa,YAArB,EAAmC;MAC/Bb,MAAM,CAACa,YAAP,CAAoB/J,SAApB,EAA+B,IAA/B;IACH;;IACD,KAAK,MAAM,GAAGO,MAAH,CAAX,IAAyBP,SAAS,CAACQ,OAAnC,EAA4C;MACxCD,MAAM,CAACyJ,eAAP,IAA0BzJ,MAAM,CAACyJ,eAAP,CAAuB,IAAvB,CAA1B;IACH;EACJ;;EACDC,cAAc,GAAG;IACb,MAAMzK,MAAM,GAAG,KAAK4B,SAAL,EAAf;IAAA,MAAiCL,UAAU,GAAG,KAAKf,SAAL,CAAegB,MAAf,CAAsBC,IAApE;IAAA,MAA0EhB,QAAQ,GAAG,KAAKA,QAA1F;IACA,OAAQA,QAAQ,CAACY,CAAT,IAAc,CAACrB,MAAf,IACJS,QAAQ,CAACa,CAAT,IAAc,CAACtB,MADX,IAEJS,QAAQ,CAACa,CAAT,IAAcC,UAAU,CAACa,MAAX,GAAoBpC,MAF9B,IAGJS,QAAQ,CAACY,CAAT,IAAcE,UAAU,CAACU,KAAX,GAAmBjC,MAHrC;EAIH;;EACD0K,SAAS,GAAG;IACR,OAAO,CAAC,KAAKnE,SAAN,IAAmB,CAAC,KAAK2D,QAAzB,IAAqC,KAAKO,cAAL,EAA5C;EACH;;EACD1D,KAAK,GAAG;IACJ,KAAK,MAAMF,OAAX,IAAsB,KAAKrG,SAAL,CAAe2D,SAAf,CAAyB2C,QAA/C,EAAyD;MACrDD,OAAO,CAACE,KAAR,IAAiBF,OAAO,CAACE,KAAR,CAAc,IAAd,CAAjB;IACH;EACJ;;AAxRiB"},"metadata":{},"sourceType":"module"}